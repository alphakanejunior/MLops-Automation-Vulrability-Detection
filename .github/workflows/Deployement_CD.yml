# =============================================================
# CD - Secure ML Deployment Pipeline
# =============================================================
# Objectif :
# - Appliquer un Security Gate basé sur les CVE
# - Builder l’image Docker
# - Scanner l’image Docker (Trivy - BLOQUANT)
# - Push dans GHCR
# - Déployer sur VM via SSH
# - Vérifier la santé de l’application
# ============================================================

name: CD - Secure ML Deployment Pipeline

on:
  # 1️⃣ Merge PR vers main
  pull_request:
    branches:
      - main
    types:
      - closed

  # 2️⃣ Push direct sur main
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: mlapp
  TIMESTAMP: ${{ github.run_id }}

jobs:
  # =============================================================
  # Job 1 : Security Gate (CVE enrichies depuis le CI)
  # =============================================================
  SecurityGate:
    name: Security Gate (CVE Policy)
    runs-on: ubuntu-latest

    steps:
      # Récupération du code (utile pour scripts / contexte)
      - uses: actions/checkout@v4

      # Téléchargement du rapport CVE enrichi produit en CI
      - name: Download Enriched CVE Report
        uses: actions/download-artifact@v4
        with:
          name: enriched-cve-report-latest
          path: reports/cve


      # Politique de sécurité :
      # - BLOQUE le pipeline si une CVE CRITICAL est détectée
      - name: Evaluate CVE Policy
        run: |
          python << 'EOF'
          import json, sys

          with open("reports/cve/enriched_cves.json") as f:
              data = json.load(f)

          vulns = data.get("vulnerabilities", [])
          critical = [v for v in vulns if v.get("severity") == "CRITICAL"]

          if critical:
              print("❌ CRITICAL CVEs detected:")
              for v in critical:
                  print(f"- {v.get('cve_id')}")
              sys.exit(1)

          print("✅ CVE gate passed (no CRITICAL vulnerabilities)")
          EOF

  # ============================================================
  # Job 2 : Build de l’image Docker (local runner)
  # =============================================================
  BuildImage:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: SecurityGate

    steps:
      - uses: actions/checkout@v4

      # Build local uniquement (pas encore pushée)
      - name: Build Docker Image
        run: |
          docker build \
            -t ${{ env.IMAGE_NAME }}:${{ github.sha }} \
            .

  # =============================================================
  # Job 3 : Scan de l’image Docker finale (BLOQUANT)
  # =============================================================
  ImageScan:
    name: Trivy Scan - Docker Image
    runs-on: ubuntu-latest
    needs: BuildImage

    steps:
      # Installation manuelle de Trivy (version maîtrisée)
      - name: Install Trivy
        run: |
          TRIVY_VERSION="0.68.1"
          wget -q https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz
          tar zxvf trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz
          sudo mv trivy /usr/local/bin/

      # Scan BLOQUANT :
      # - HIGH et CRITICAL
      # - ignore les vulnérabilités non corrigées
      - name: Scan Docker Image (blocking)
        run: |
          trivy image \
            --exit-code 1 \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            ${{ env.IMAGE_NAME }}:${{ github.sha }}

  # =============================================================
  # Job 4 : Push de l’image dans GHCR
  # =============================================================
  PushImage:
    name: Push Docker Image
    runs-on: ubuntu-latest
    needs: ImageScan

    steps:
      - uses: actions/checkout@v4

      # Authentification au registre GHCR
      - name: Login to GHCR
        run: |
          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io \
            -u "${{ github.actor }}" \
            --password-stdin

      # Tag + Push uniquement si scan OK
      - name: Tag & Push Image
        run: |
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} \
            ghcr.io/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

          docker push ghcr.io/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  # =============================================================
  # Job 5 : Déploiement sur VM (SSH sécurisé)
  # =============================================================
  Deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: PushImage

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            docker pull ghcr.io/${{ github.repository }}/mlapp:${{ github.sha }}

            docker stop mlapp || true
            docker rm mlapp || true

            docker run -d \
              --name mlapp \
              -p 8000:8000 \
              ghcr.io/${{ github.repository }}/mlapp:${{ github.sha }}

  # =============================================================
  # Job 6 : Health Check post-déploiement
  # =============================================================
  HealthCheck:
    name: Health Check
    runs-on: ubuntu-latest
    needs: Deploy

    steps:
      # Attente pour laisser l’app démarrer
      - name: Wait for startup
        run: sleep 15

      # Vérification endpoint /health
      - name: API Health Check
        run: |
          curl -f http://${{ secrets.VM_HOST }}:8000/health
